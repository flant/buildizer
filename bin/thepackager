#!/usr/bin/env ruby
# vi: set ft=ruby :
# vi: set sts=2 ts=2 sw=2 :

require 'thor'
require 'yaml'
require 'net_status'
require 'pathname'
require 'mixlib/shellout'
require 'net_status'
require 'pry'

module Thepackager
  module Refine
    refine String do
      def underscore
        self.gsub(/(.)([A-Z])/,'\1_\2').downcase
      end
    end
  end # Refine

  using Refine

  module Concern
    def self.included(base)
      base.send(:extend, ClassMethods) if defined? ClassMethods
    end

    def command(*command_args, do_raise: nil)
      Mixlib::ShellOut.new(*command_args).tap do |cmd|
        cmd.live_stdout = $stdout
        cmd.run_command
        if not cmd.status.success? and do_raise
          raise Error.new(error: :error, message: [cmd.stdout, cmd.stderr].join("\n"))
        end
        cmd
      end
    end

    def command!(*command_args)
      command(*command_args, do_raise: true)
    end
  end # Concern

  class Error < NetStatus::Exception
  end # Error

  module Image
    class Base
      include Concern

      attr_reader :instructions
      attr_reader :docker
      attr_reader :target
      attr_reader :package_name
      attr_reader :package_version

      def initialize(docker, target:, package_name:, package_version:)
        @instructions = []

        @docker = docker
        @target = target
        @package_name = package_name
        @package_version = package_version

        instruction :FROM, base_image
      end

      def os_name
        raise
      end

      def os_version
        raise
      end

      def build_dep(build_dep)
        raise
      end

      def install_ruby_instructions(&blk)
        [%Q{\
curl -sSL https://rvm.io/mpapis.asc | gpg --import -; \
curl -sSL https://get.rvm.io | bash -s stable},
         %Q{rvm install 2.2.1 --quiet-curl}]
      end

      def install_fpm_instructions
        'gem install fpm'
      end

      def base_image
        "thepackager/#{os_name}:#{os_version}"
      end

      def name
        "#{docker.builder.packager.docker_image || "thepackager/#{package_name}"}:#{target}"
      end

      def instruction(instruction, cmd)
        instructions << [instruction.to_s.upcase, cmd].join(' ')
      end
    end # Base

    class Ubuntu < Base
      attr_reader :os_version

      def initialize(docker, os_version, **kwargs)
        @os_version = os_version
        super(docker, **kwargs)
      end

      def os_name
        'ubuntu'
      end

      def build_dep(build_dep)
        instruction :RUN, "apt-get build-dep -y #{build_dep.to_a.join(' ')}"
      end
    end # Ubuntu

    class Ubuntu1204 < Ubuntu
      def initialize(docker, **kwargs)
        super(docker, '12.04', **kwargs)
      end
    end # Ubuntu1204

    class Ubuntu1404 < Ubuntu
      def initialize(docker, **kwargs)
        super(docker, '14.04', **kwargs)
      end
    end # Ubuntu1404

    class Centos < Base
      attr_reader :os_version

      def initialize(docker, os_version, **kwargs)
        @os_version = os_version
        super(docker, **kwargs)
      end

      def os_name
        'centos'
      end

      def build_dep(build_dep)
        instruction :RUN, "yum-builddep -y #{build_dep.to_a.join(' ')}"
      end

      def add_repo(id:, name:, baseurl: nil, enabled: 1, gpgcheck: nil, gpgkey: nil, exclude: nil, includepkgs: nil, mirrorlist: nil)
        repo = "[#{id}]\
\\nname=#{name}\
\\nenabled=#{enabled}\
#{baseurl ? "\\nbaseurl=#{baseurl}" : nil}\
#{mirrorlist ? "\\nmirrorlist=#{mirrorlist}" : nil}\
#{gpgcheck ? "\\ngpgcheck=#{gpgcheck}" : nil}\
#{gpgkey ? "\\ngpgkey=#{gpgkey}" : nil}\
#{exclude ? "\\nexclude=#{exclude}" : nil}\
#{includepkgs ? "\\nincludepkgs=#{includepkgs}" : nil}"

        instruction :RUN, "bash -lec \"echo -e '#{repo}' >> /etc/yum.repos.d/CentOS-Extra-Thepackager.repo\""
      end
    end # Centos

    class Centos6 < Centos
      def initialize(docker, **kwargs)
        super(docker, 'centos6', **kwargs)
      end
    end # Centos6

    class Centos7 < Centos
      def initialize(docker, **kwargs)
        super(docker, 'centos7', **kwargs)
      end
    end # Centos7
  end # Image

  class Docker
    include Concern

    attr_reader :builder
    attr_reader :username
    attr_reader :password
    attr_reader :email
    attr_reader :server

    def initialize(builder, username:, password:, email:, server: nil)
      @builder = builder
      @username = username
      @password = password
      @email = email
      @server = server
    end

    def new_image(os_name, os_version, **kwargs)
      klass = ({
        'ubuntu' => {
          '12.04' => Image::Ubuntu1204,
          '14.04' => Image::Ubuntu1404,
          nil => Image::Ubuntu1404,
        },
        'centos' => {
          'centos6' => Image::Centos6,
          'centos7' => Image::Centos7,
          nil => Image::Centos7,
        },
      }[os_name] || {})[os_version]
      raise Error, message: "unknown os '#{[os_name, os_version].compact.join('-')}'" unless klass
      klass.new(self, **kwargs)
    end

    def login!
      docker_login = ["docker login --email=#{email} --username=#{username} --password=#{password}"]
      docker_login << "--server=#{server}" if server
      command! docker_login.join(' ')
    end

    def logout!
      command! 'docker logout'
    end

    def pull_image!(image)
      command "docker pull #{image.name}"
    end

    def push_image!(image)
      command! "docker push #{image.name}"
    end

    def build_image!(image)
      pull_image! image

      build_path = builder.build_path.join(image.os_name).join(image.os_version)
      build_path.mkpath
      build_path.join('Dockerfile').write [*image.instructions, nil].join("\n")
      command! "docker build -t #{image.name} #{build_path}"

      push_image! image
    end
  end # Docker

  module Builder
    class Base
      include Concern

      attr_reader :packager
      attr_reader :build_path
      attr_reader :docker

      def initialize(packager)
        @packager = packager

        @build_path = Pathname.new(ENV['PREFIX'] || 'build')
        raise Error, message: "bad build prefix: '#{build_path}' is a file" if build_path.file?
        build_path.mkdir rescue nil

        @docker = Docker.new(self,
          username: packager.docker_username,
          password: packager.docker_password,
          email: packager.docker_email,
          server: packager.docker_server,
        )
      end

      def build_type
        raise
      end

      def prepare_image_instructions
      end

      def build_dep
      end

      def base_image_params
        {}.tap do |params|
          params[:package_name] = packager.package_name
          params[:package_version] = packager.package_version
          params[:prepare] = packager.prepare
          params[:build_dep] = packager.build_dep
        end
      end

      def merge_params(a: nil, b:, &blk)
        a ||= base_image_params

        {}.tap do |res|
          yield a, b if block_given?
          res[:package_name] = a[:package_name] || b['package_name']
          res[:package_version] = a[:package_version] || b['package_version']
          res[:prepare] = a[:prepare] + Array(b['prepare'])
          res[:build_dep] = a[:build_dep] | Array(b['build_dep']).to_set
        end
      end

			def merge_os_params(os_name, **kwargs, &blk)
        merge_params(kwargs.merge( b: packager.os_params(os_name) ), &blk)
      end

			def merge_os_version_params(os_name, os_version, **kwargs, &blk)
        merge_params(kwargs.merge( b: packager.os_params([os_name, os_version].join('-')) ), &blk)
      end

			def merge_target_params(target, target_package_name, target_package_version, **kwargs, &blk)
        merge_params(kwargs.merge( b: {'package_name' => target_package_name, 'package_version' => target_package_version} ), &blk)
      end

      def check_params!(params)
        raise(Error, error: :input_error, message: "package_name is not defined") unless params[:package_name]
        raise(Error, error: :input_error, message: "package_version is not defined") unless params[:package_version]
      end

      def prepare
        docker.login!

        packager.before_prepare.each {|cmd| command! cmd}

        packager.targets.map {|target|
          os_name, os_version, target_package_name, target_package_version = target.split('-', 4)
          params = merge_os_params(os_name)
          params = merge_os_version_params(os_name, os_version, a: params) if os_version
          params = merge_target_params(target, target_package_name, target_package_version, a: params) if target_package_name
          params[:target] = target

          check_params! params

          [os_name, os_version, params]
        }.each {|a| prepare_image(*a)}

        packager.after_prepare.each {|cmd| command! cmd}

        docker.logout!
      end

      def prepare_image(os_name, os_version,
                        prepare: [], build_dep: [],
                        package_name:, package_version:, target:)
        image = docker.new_image(os_name, os_version, target: target, package_name: package_name, package_version: package_version)
        (Array(self.prepare_image_instructions(image)) + prepare).each do |cmd|
          image.instruction(:RUN, "bash -lec \"#{cmd}\"")
        end
        image.build_dep(Array(self.build_dep).to_set + build_dep)
        docker.build_image!(image)
      end

      def build
        docker.login!
        puts "#{self.class}::build #TODO"
        docker.logout!
      end

      def deploy
        puts "#{self.class}::deploy #TODO"
      end
    end # Base

    class Fpm < Base
      def build_type
        'fpm'
      end

      def base_image_params
        super.tap do |params|
          raise(Error,
            error: :input_error,
            message: [
              "cannot define package_version in '#{build_type}'",
              "build type (TRAVIS_TAG, CI_BUILD_TAG env variables)"
            ].join(' ')
          ) if params[:package_version]
          params[:package_version] = ENV['TRAVIS_TAG'] || ENV['CI_BUILD_TAG']
        end
      end

      def prepare_image_instructions(image)
        [*Array(image.install_ruby_instructions),
         *Array(image.install_fpm_instructions)]
      end

      def cannot_redefine_package_params!(params, redefine_for: nil)
        [:package_name, :package_version].each do |param|
          raise(Error,
            error: :input_error,
            message: [
              "cannot redefine #{param}",
              redefine_for ? "for #{redefine_for}" : nil,
              "in '#{build_type}' build_type",
            ].compact.join(' ')
          ) if params.key? param.to_s
        end
      end

			def merge_os_params(os_name, **kwargs, &blk)
        super(os_name, **kwargs) do |a, b|
          cannot_redefine_package_params!(b, redefine_for: "os '#{os_name}'")
          yield if block_given?
        end
      end

			def merge_os_version_params(os_name, os_version, **kwargs, &blk)
        super(os_name, os_version, **kwargs) do |a, b|
          cannot_redefine_package_params!(b, redefine_for: "os version '#{os_name}-#{os_version}'")
          yield if block_given?
        end
      end

			def merge_target_params(target, target_package_name, target_package_version, **kwargs, &blk)
        super(target, target_package_name, target_package_version, **kwargs) do |a, b|
          cannot_redefine_package_params!(b, redefine_for: "target '#{target}'")
          yield if block_given?
        end
      end
    end # Fpm
  end # Builder

  class Packager
    attr_reader :package_path
    attr_reader :packagefile_path
    attr_reader :options_path
    attr_reader :travis_path

    def initialize(options: {})
      @package_path = Pathname.new(ENV['THEPACKAGER_PATH'] || '.')
      @packagefile_path = package_path.join('Packagefile')
      @options_path = package_path.join('.thepackager.yml')
      @travis_path = package_path.join('.travis.yml')
      @_options = options
    end

    def initialized?
      options_path.exist?
    end

    def init!
      raise Error, error: :logical_error, message: "already initialized" if initialized?

      git_precommit_init!
      options_setup!
      travis_setup!
    end

    def deinit!
      raise Error, error: :logical_error, message: "not initialized" unless initialized?
      options_path.delete
      git_precommit_deinit!
    end

    def update!
      travis_setup!
    end

    def prepare!
      builder.prepare
    end

    def build!
      builder.build
    end

    def deploy!
      builder.deploy # TODO
    end

    def packagefile
      @packagefile ||= YAML.load(packagefile_path.read)
    end

    def options
      @options ||= (YAML.load(options_path.read) rescue {}).merge(@_options)
    end

    def options_setup!
      options_path.write YAML.dump(options)
      @options = nil
    end

    def travis
      @travis ||= (travis_path.exist? ? YAML.load(travis_path.read) : {})
    rescue Psych::Exception => err
      raise Error, error: :input_error, message: "bad travis config file #{file}: #{err.message}"
    end

    def travis_setup!
      install = [
        'sudo apt-get update',
        'sudo apt-get install -y apt-transport-https ca-certificates',
        'sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D',
        'echo "deb https://apt.dockerproject.org/repo ubuntu-trusty main" | sudo tee /etc/apt/sources.list.d/docker.list',
        'sudo apt-get update',
        'sudo apt-get -o dpkg::options::="--force-confnew" install -y docker-engine=1.9.1-0~trusty', # FIXME [https://github.com/docker/docker/issues/20316]
        'echo "docker-engine hold" | sudo dpkg --set-selections',
      ]
      install.push(*Array(thepackager_install_instructions(latest: options['latest'])))

      env = targets.map {|t| "THEPACKAGER_TARGET=#{t}"}

      travis_path.write YAML.dump(travis.merge(
        'dist' => 'trusty',
        'sudo' => 'required',
        'cache' => ['apt', 'bundler'],
        'language' => 'ruby',
        'rvm' => '2.2.1',
        'install' => install,
        'before_script' => 'thepackager prepare',
        'script' => 'thepackager build',
        'deploy' => {
          'provider' => 'script',
          'script' => 'thepackager deploy',
        },
        'env' => env,
      ))
      @travis = nil
    end

    def git_hooks_path
      package_path.join('.git').join('hooks')
    end

    def git_old_hooks_path
      git_hooks_path.join('old-hooks')
    end

    def git_precommit_path
      git_hooks_path.join('pre-commit')
    end

    def git_old_precommit_path
      git_old_hooks_path.join('pre-commit')
    end

    def git_precommit_init!
      if git_precommit_path.exist?
        raise(Error,
          error: :logical_error,
          message: [
            "unable to backup existing precommit script: ",
            "file already exists: #{git_old_precommit_path}",
          ].join) if git_old_precommit_path.exist?
        git_old_hooks_path.mkpath
        FileUtils.cp git_precommit_path, git_old_precommit_path
      end

      git_precommit_path.write <<-EOF
#!/bin/bash
thepackager update
git add -v .travis.yml
      EOF
      git_precommit_path.chmod 0755
    end

    def git_precommit_deinit!
      git_precommit_path.delete if git_precommit_path.exist?
      FileUtils.cp git_old_precommit_path, git_precommit_path if git_old_precommit_path.exist?
      git_old_hooks_path.rmtree if git_old_hooks_path.exist?
    end

    def package_name
      packagefile['package_name']
    end

    def package_version
      packagefile['package_version']
    end

    def os_params(os)
      packagefile['os'].to_h[os.to_s].to_h
    end

    def before_prepare
      Array(packagefile['before_prepare'])
    end

    def after_prepare
      Array(packagefile['after_prepare'])
    end

    def targets
      targets = Array(packagefile['target'])
      restrict_targets = ENV['THEPACKAGER_TARGET']
      restrict_targets = restrict_targets.split(',').map(&:strip) if restrict_targets
      targets = targets & restrict_targets if restrict_targets
      targets
    end

    def prepare
      Array(packagefile['prepare'])
    end

    def build_dep
      Array(packagefile['build_dep']).to_set
    end

    def docker_server
      packagefile['docker_server']
    end

    def docker_image
      packagefile['image']
    end

    def docker_username
      ENV['THEPACKAGER_DOCKER_USERNAME'] || begin
        raise Error, error: :input_error, message: "THEPACKAGER_DOCKER_USERNAME env variable required"
      end
    end

    def docker_password
      ENV['THEPACKAGER_DOCKER_PASSWORD'] || begin
        raise Error, error: :input_error, message: "THEPACKAGER_DOCKER_PASSWORD env variable required"
      end
    end

    def docker_email
      ENV['THEPACKAGER_DOCKER_EMAIL'] || begin
        raise Error, error: :input_error, message: "THEPACKAGER_DOCKER_EMAIL env variable required"
      end
    end

    def builder
      @builder ||= begin
        build_type = packagefile['build_type']
        klass = {'fpm' => Builder::Fpm}[build_type]
        raise Error, error: :input_error, message: "unknown build_type '#{build_type}'" unless klass
        klass.new(self)
      end
    end

    def thepackager_install_instructions(latest: nil)
      if latest
        ['git clone https://github.com/flant/thepackager ~/thepackager',
         'echo "export BUNDLE_GEMFILE=~/thepackager/Gemfile" | tee -a ~/.bashrc',
         'export BUNDLE_GEMFILE=~/thepackager/Gemfile',
         'gem install bundler',
         'bundle install',
        ]
      else
        'gem install thepackager'
      end
    end
  end # Packager

  class Cli < Thor
    desc "init", "Initialize settings (travis config, thepackager config, git pre-commit hook)"
    method_option :latest,
      type: :boolean,
      desc: "use thepackager github master branch"
    def init
      Packager.new(options: options).init!
    end

    desc "update", "Regenerate .travis.yml"
    def update
      Packager.new(options: options).update!
    end

    desc "deinit", "Deinitialize settings (thepackager config, git pre-commit hook)"
    def deinit
      Packager.new(options: options).deinit!
    end

    desc "prepare", "Prepare images for building packages"
    def prepare
      Packager.new(options: options).prepare!
    end

    desc "build", "Build packages"
    def build
      Packager.new(options: options).build!
    end

    desc "deploy", "Deploy packages"
    def deploy
      Packager.new(options: options).deploy!
    end
  end # Cli
end # Thepackager

begin
  Thepackager::Cli.start
rescue Thepackager::Error => e
  $stderr.puts [e.net_status[:error], e.net_status[:message]].compact.join(': ')
  exit 1
end
