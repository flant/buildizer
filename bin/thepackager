#!/usr/bin/env ruby
# vi: set ft=ruby :
# vi: set sts=2 ts=2 sw=2 :

require 'thor'
require 'yaml'
require 'net_status'
require 'pathname'
require 'mixlib/shellout'
require 'net_status'
require 'pry'

module Thepackager
  module Refine
    refine String do
      def underscore
        self.gsub(/(.)([A-Z])/,'\1_\2').downcase
      end
    end
  end # Refine

  using Refine

  module Concern
    def self.included(base)
      base.send(:extend, ClassMethods) if defined? ClassMethods
    end

    def command(*command_args, do_raise: nil)
      Mixlib::ShellOut.new(*command_args).tap do |cmd|
        cmd.live_stdout = $stdout
        cmd.run_command
        if not cmd.status.success? and do_raise
          raise Error.new(error: :error, message: [cmd.stdout, cmd.stderr].join("\n"))
        end
        cmd
      end
    end

    def command!(*command_args)
      command(*command_args, do_raise: true)
    end
  end # Concern

  class Error < NetStatus::Exception
  end # Error

  module Target
    class Base
      attr_reader :builder
      attr_reader :image

      attr_reader :name
      attr_reader :package_name
      attr_reader :package_version
      attr_reader :prepare
      attr_reader :build_dep
      attr_reader :before_build

      def initialize(builder, image,
                     name:, package_name:, package_version:,
                     prepare: [], build_dep: [], before_build: [])
        @builder = builder
        @image = image

        @name = name
        @package_name = package_name
        @package_version = package_version
        @prepare = prepare
        @build_dep = build_dep
        @before_build = before_build
      end

      def docker_image
        "#{builder.packager.docker_image || "thepackager/#{package_name}"}:#{name}"
      end
    end # Base

    class Fpm < Base
      attr_reader :fpm_script
      attr_reader :fpm_config_files
      attr_reader :fpm_files

      def initialize(builder, image, fpm_script: [], fpm_config_files: {}, fpm_files: {}, **kwargs)
        super(builder, image, **kwargs)

        @fpm_script = fpm_script
        @fpm_config_files = fpm_config_files
        @fpm_files = fpm_files
      end
    end # Fpm
  end # Target

  module Image
    class Base
      include Concern

      attr_reader :instructions
      attr_reader :docker

      attr_accessor :target

      def initialize(docker, **kwargs)
        @instructions = []
        @docker = docker

        instruction :FROM, base_image
      end

      def os_name
        raise
      end

      def os_version
        raise
      end

      def fpm_output_type
        raise
      end

      def fpm_extra_params
      end

      def build_dep(build_dep)
        raise
      end

      def install_ruby_instructions(&blk)
        [%Q{\
curl -sSL https://rvm.io/mpapis.asc | gpg --import -; \
curl -sSL https://get.rvm.io | bash -s stable},
         %Q{rvm install 2.2.1 --quiet-curl}]
      end

      def install_fpm_instructions
        'gem install fpm'
      end

      def base_image
        "thepackager/#{os_name}:#{os_version}"
      end

      def name
        target.docker_image
      end

      def instruction(instruction, cmd)
        instructions << [instruction.to_s.upcase, cmd].join(' ')
      end
    end # Base

    class Ubuntu < Base
      attr_reader :os_version

      def initialize(docker, os_version, **kwargs)
        @os_version = os_version
        super(docker, **kwargs)
      end

      def os_name
        'ubuntu'
      end

      def fpm_output_type
        'deb'
      end

      def fpm_extra_params
        Array(super).tap do |res|
          res << '--deb-use-file-permissions'
          res << '--deb-no-default-config-files'
        end
      end

      def build_dep(build_dep)
        instruction :RUN, "apt-get build-dep -y #{build_dep.to_a.join(' ')}" if build_dep.any?
      end
    end # Ubuntu

    class Ubuntu1204 < Ubuntu
      def initialize(docker, **kwargs)
        super(docker, '12.04', **kwargs)
      end
    end # Ubuntu1204

    class Ubuntu1404 < Ubuntu
      def initialize(docker, **kwargs)
        super(docker, '14.04', **kwargs)
      end
    end # Ubuntu1404

    class Centos < Base
      attr_reader :os_version

      def initialize(docker, os_version, **kwargs)
        @os_version = os_version
        super(docker, **kwargs)
      end

      def os_name
        'centos'
      end

      def build_dep(build_dep)
        instruction :RUN, "yum-builddep -y #{build_dep.to_a.join(' ')}" if build_dep.any?
      end

      def add_repo(id:, name:, baseurl: nil, enabled: 1, gpgcheck: nil, gpgkey: nil, exclude: nil, includepkgs: nil, mirrorlist: nil)
        repo = "[#{id}]\
\\nname=#{name}\
\\nenabled=#{enabled}\
#{baseurl ? "\\nbaseurl=#{baseurl}" : nil}\
#{mirrorlist ? "\\nmirrorlist=#{mirrorlist}" : nil}\
#{gpgcheck ? "\\ngpgcheck=#{gpgcheck}" : nil}\
#{gpgkey ? "\\ngpgkey=#{gpgkey}" : nil}\
#{exclude ? "\\nexclude=#{exclude}" : nil}\
#{includepkgs ? "\\nincludepkgs=#{includepkgs}" : nil}"

        instruction :RUN, "bash -lec \"echo -e '#{repo}' >> /etc/yum.repos.d/CentOS-Extra-Thepackager.repo\""
      end
    end # Centos

    class Centos6 < Centos
      def initialize(docker, **kwargs)
        super(docker, 'centos6', **kwargs)
      end
    end # Centos6

    class Centos7 < Centos
      def initialize(docker, **kwargs)
        super(docker, 'centos7', **kwargs)
      end
    end # Centos7
  end # Image

  class Docker
    include Concern

    attr_reader :builder
    attr_reader :username
    attr_reader :password
    attr_reader :email
    attr_reader :server

    def initialize(builder, username:, password:, email:, server: nil)
      @builder = builder
      @username = username
      @password = password
      @email = email
      @server = server
    end

    def image_klass(os_name, os_version)
      ({
        'ubuntu' => {
          '12.04' => Image::Ubuntu1204,
          '14.04' => Image::Ubuntu1404,
          nil => Image::Ubuntu1404,
        },
        'centos' => {
          'centos6' => Image::Centos6,
          'centos7' => Image::Centos7,
          nil => Image::Centos7,
        },
      }[os_name] || {})[os_version]
    end

    def new_image(os_name, os_version, **kwargs)
      klass = image_klass(os_name, os_version)
      raise Error, message: "unknown os '#{[os_name, os_version].compact.join('-')}'" unless klass
      klass.new(self, **kwargs)
    end

    def login!
      docker_login = ["docker login --email=#{email} --username=#{username} --password=#{password}"]
      docker_login << "--server=#{server}" if server
      command! docker_login.join(' ')
    end

    def logout!
      command! 'docker logout'
    end

    def pull_image!(image)
      command "docker pull #{image.name}"
    end

    def push_image!(image)
      command! "docker push #{image.name}"
    end

    def build_image!(image)
      pull_image! image

      build_path = builder.build_path.join(image.os_name).join(image.os_version)
      build_path.mkpath
      build_path.join('Dockerfile').write [*image.instructions, nil].join("\n")
      command! "docker build -t #{image.name} #{build_path}"

      push_image! image
    end

    def image_build_path(image)
      builder.build_path.join(image.os_name).join(image.os_version)
    end

    def container_package_path
      Pathname.new('/package')
    end

    def container_build_path
      container_package_path.join('build')
    end

    def run!(image, cmd:)
      cmd = Array(cmd)

      command! [
        "docker run --rm",
        "-v #{builder.packager.package_path}:#{container_package_path}",
        "-v #{image_build_path(image)}:#{container_build_path}",
        image.name,
        "'#{cmd.join('; ')}'"
      ].join(' ')
    end
  end # Docker

  module Builder
    class Base
      include Concern

      attr_reader :packager
      attr_reader :build_path
      attr_reader :docker

      def initialize(packager)
        @packager = packager

        @build_path = Pathname.new(ENV['PREFIX'] || packager.package_path.join('build')).expand_path
        raise Error, message: "bad build prefix: '#{build_path}' is a file" if build_path.file?
        build_path.mkdir rescue nil

        @docker = Docker.new(self,
          username: packager.docker_username,
          password: packager.docker_password,
          email: packager.docker_email,
          server: packager.docker_server,
        )
      end

      def build_type
        raise
      end

      def target_klass
        raise
      end

      def prepare_image_instructions(target)
      end

      def build_instructions(target)
      end

      def build_dep
      end

      def new_target(target_name)
        os_name, os_version, target_package_name, target_package_version = target_name.split('-', 4)

        image = docker.new_image(os_name, os_version)

        params = merge_os_params(image.os_name)
        params = merge_os_version_params(image.os_name, image.os_version, into: params)
        params = merge_base_target_params(target_name, target_package_name, target_package_version,
                                          into: params) if target_package_name
        check_params! params

        target_klass.new(self, image, name: target_name, **params).tap do |target|
          image.target = target
        end
      end

      def targets
        @targets ||= packager.targets.map {|target_name| new_target(target_name)}
      end

      def initial_target_params
        {}.tap do |params|
          params[:package_name] = packager.package_name
          params[:package_version] = packager.package_version
          params[:prepare] = packager.prepare
          params[:build_dep] = packager.build_dep
          params[:before_build] = packager.before_build
        end
      end

      def merge_params(into: nil, params:, &blk)
        into ||= initial_target_params
        params ||= {}
        yield into, params if block_given?
        do_merge_params into, params
      end

      def do_merge_params(into, params)
        {}.tap do |res|
          res[:package_name] = into[:package_name] || params['package_name']
          res[:package_version] = into[:package_version] || params['package_version']
          res[:prepare] = into[:prepare] + Array(params['prepare'])
          res[:build_dep] = into[:build_dep] | Array(params['build_dep']).to_set
          res[:before_build] = into[:before_build] + Array(params['before_build'])
        end
      end

      def merge_os_params(os_name, into: nil, &blk)
        merge_params(into: into, params: packager.os_params(os_name), &blk)
      end

      def merge_os_version_params(os_name, os_version, into: nil, &blk)
        merge_params(into: into,
                     params: packager.os_params([os_name, os_version].join('-')), &blk)
      end

      def merge_base_target_params(target, target_package_name, target_package_version,
                                   into: nil, &blk)
        merge_params(into: into,
                     params: {'package_name' => target_package_name,
                              'package_version' => target_package_version}, &blk)
      end

      def check_params!(params)
        [:package_name, :package_version].each do |param|
          raise(Error,
                error: :input_error,
                message: "#{param} is not defined") unless params[param] and not params[param].empty?
        end
      end

      def prepare
        docker.login!

        begin
          packager.before_prepare.each {|cmd| command! cmd}
          targets.each {|target| prepare_target_image(target)}
          packager.after_prepare.each {|cmd| command! cmd}
        ensure
          docker.logout!
        end
      end

      def prepare_target_image(target)
        (Array(prepare_image_instructions(target)) + target.prepare).each do |cmd|
          target.image.instruction(:RUN, "bash -lec \"#{cmd}\"")
        end
        target.image.build_dep(Array(build_dep).to_set + target.build_dep)
        docker.build_image! target.image
      end

      def build
        targets.each {|target| build_target(target)}
      end

      def build_target(target)
        cmd = [
          "cd /package",
          *target.before_build,
          *Array(build_instructions(target)),
        ]

        docker.run! target.image, cmd: cmd
      end

      def deploy
        puts "#{self.class}::deploy #TODO"
      end
    end # Base

    class Fpm < Base
      FPM_SCRIPT_EVENTS = [:before, :after].map {|at|
                            [:install, :upgrade, :remove].map {|event|
                              "#{at}_#{event}"}}.flatten

      def build_type
        'fpm'
      end

      def target_klass
        Target::Fpm
      end

      def initial_target_params
        super.tap do |params|
          raise(Error,
                error: :input_error,
                message: [
                  "explicit definition of package_version in '#{build_type}' ",
                  "build type is forbidden ",
                  "(use TRAVIS_TAG, CI_BUILD_TAG env variables)",
                ].join) if params[:package_version]
          params[:package_version] = ENV['TRAVIS_TAG'] || ENV['CI_BUILD_TAG']
          params[:fpm_script] = Array(packager.packagefile['fpm_script'])
          params[:fpm_config_files] = packager.packagefile['fpm_config_files'].to_h
          params[:fpm_files] = packager.packagefile['fpm_files'].to_h
        end
      end

      def cannot_redefine_package_params!(params, redefine_for: nil)
        [:package_name, :package_version].each do |param|
          raise(Error,
            error: :input_error,
            message: [
              "cannot redefine #{param}",
              redefine_for ? "for #{redefine_for}" : nil,
              "in '#{build_type}' build_type",
            ].compact.join(' ')
          ) if params.key? param.to_s
        end
      end

      def do_merge_params(into, params)
        super.tap do |res|
          res[:fpm_script] = into[:fpm_script] + Array(params['fpm_script'])
          res[:fpm_config_files] = into[:fpm_config_files].merge params['fpm_config_files'].to_h
          res[:fpm_files] = into[:fpm_files].merge params['fpm_files'].to_h
        end
      end

      def merge_os_params(os_name, **kwargs, &blk)
        super(os_name, **kwargs) do |into, params|
          yield into, params if block_given?
          cannot_redefine_package_params!(params, redefine_for: "os '#{os_name}'")
        end
      end

      def merge_os_version_params(os_name, os_version, **kwargs, &blk)
        super(os_name, os_version, **kwargs) do |into, params|
          yield into, params if block_given?
          cannot_redefine_package_params!(params,
                                          redefine_for: "os version '#{os_name}-#{os_version}'")
        end
      end

      def merge_base_target_params(target, target_package_name, target_package_version, **kwargs, &blk)
        super(target, target_package_name, target_package_version, **kwargs) do |into, params|
          yield into, params if block_given?
          cannot_redefine_package_params!(params, redefine_for: "target '#{target}'")
        end
      end

      def prepare_image_instructions(target)
        [*Array(target.image.install_ruby_instructions),
         *Array(target.image.install_fpm_instructions)]
      end

      def build_instructions(target)
        fpm_script = target.fpm_script.reduce({}) do |res, spec|
          cmd = Array(spec['do'])
          next res unless cmd.any?
          Array(spec['when']).each do |_when|
            raise(
              Error,
              message: "unknown fpm_script event #{_when.inspect}"
            ) unless FPM_SCRIPT_EVENTS.include? _when
            res[_when] ||= {fpm_option: "--#{_when.split('_').join('-')}",
                            file: docker.image_build_path(target.image).join("fpm_#{_when}.sh"),
                            container_file: Pathname.new('/package/build').join("fpm_#{_when}.sh"),
                            cmd: []}
            res[_when][:cmd] += cmd
          end
          res
        end

        fpm_script.values.map do |desc|
          desc[:file].write ["#!/bin/bash", *desc[:cmd], nil].join("\n")
          desc[:file].chmod 0755
        end

        p ["fpm -s dir",
         "--force",
         "-p #{docker.container_build_path}",
         "-t #{target.image.fpm_output_type}",
         "-n #{target.package_name}",
         "-v #{target.package_version}",
         *fpm_script.values.map {|desc| "#{desc[:fpm_option]}=#{desc[:container_file]}"},
         *Array(target.image.fpm_extra_params),
         *target.fpm_config_files.values.map {|p| "--config-files=#{p}"},
         *target.fpm_files.merge(target.fpm_config_files).map {|p1, p2| "#{p1}=#{p2}"}].join(' ')
      end
    end # Fpm
  end # Builder

  class Packager
    attr_reader :package_path
    attr_reader :packagefile_path
    attr_reader :options_path
    attr_reader :travis_path

    def initialize(options: {})
      @package_path = Pathname.new(ENV['THEPACKAGER_PATH'] || '.').expand_path
      @packagefile_path = package_path.join('Packagefile')
      @options_path = package_path.join('.thepackager.yml')
      @travis_path = package_path.join('.travis.yml')
      @_options = options
    end

    def initialized?
      options_path.exist?
    end

    def init!
      raise Error, error: :logical_error, message: "already initialized" if initialized?

      git_precommit_init!
      options_setup!
      travis_setup!
    end

    def deinit!
      raise Error, error: :logical_error, message: "not initialized" unless initialized?
      options_path.delete
      git_precommit_deinit!
    end

    def update!
      travis_setup!
    end

    def prepare!
      builder.prepare
    end

    def build!
      builder.build
    end

    def deploy!
      builder.deploy # TODO
    end

    def packagefile
      @packagefile ||= YAML.load(packagefile_path.read)
    end

    def options
      @options ||= (YAML.load(options_path.read) rescue {}).merge(@_options)
    end

    def options_setup!
      options_path.write YAML.dump(options)
      @options = nil
    end

    def travis
      @travis ||= (travis_path.exist? ? YAML.load(travis_path.read) : {})
    rescue Psych::Exception => err
      raise Error, error: :input_error, message: "bad travis config file #{file}: #{err.message}"
    end

    def travis_setup!
      install = [
        'sudo apt-get update',
        'sudo apt-get install -y apt-transport-https ca-certificates',
        'sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D',
        'echo "deb https://apt.dockerproject.org/repo ubuntu-trusty main" | sudo tee /etc/apt/sources.list.d/docker.list',
        'sudo apt-get update',
        'sudo apt-get -o dpkg::options::="--force-confnew" install -y docker-engine=1.9.1-0~trusty', # FIXME [https://github.com/docker/docker/issues/20316]
        'echo "docker-engine hold" | sudo dpkg --set-selections',
      ]
      install.push(*Array(thepackager_install_instructions(latest: options['latest'])))

      env = targets.map {|t| "THEPACKAGER_TARGET=#{t}"}

      travis_path.write YAML.dump(travis.merge(
        'dist' => 'trusty',
        'sudo' => 'required',
        'cache' => 'apt',
        'language' => 'ruby',
        'rvm' => '2.2.1',
        'install' => install,
        'before_script' => 'thepackager prepare',
        'script' => 'thepackager build',
        'deploy' => {
          'provider' => 'script',
          'script' => 'thepackager deploy',
          'on' => {
            'tags' => true,
          },
        },
        'env' => env,
      ))
      @travis = nil
    end

    def git_hooks_path
      package_path.join('.git').join('hooks')
    end

    def git_old_hooks_path
      git_hooks_path.join('old-hooks')
    end

    def git_precommit_path
      git_hooks_path.join('pre-commit')
    end

    def git_old_precommit_path
      git_old_hooks_path.join('pre-commit')
    end

    def git_precommit_init!
      if git_precommit_path.exist?
        raise(Error,
          error: :logical_error,
          message: [
            "unable to backup existing precommit script: ",
            "file already exists: #{git_old_precommit_path}",
          ].join) if git_old_precommit_path.exist?
        git_old_hooks_path.mkpath
        FileUtils.cp git_precommit_path, git_old_precommit_path
      end

      git_precommit_path.write <<-EOF
#!/bin/bash
thepackager update
git add -v .travis.yml
      EOF
      git_precommit_path.chmod 0755
    end

    def git_precommit_deinit!
      git_precommit_path.delete if git_precommit_path.exist?
      FileUtils.cp git_old_precommit_path, git_precommit_path if git_old_precommit_path.exist?
      git_old_hooks_path.rmtree if git_old_hooks_path.exist?
    end

    def package_name
      packagefile['package_name']
    end

    def package_version
      packagefile['package_version']
    end

    def os_params(os)
      packagefile['os'].to_h[os.to_s].to_h
    end

    def before_prepare
      Array(packagefile['before_prepare'])
    end

    def after_prepare
      Array(packagefile['after_prepare'])
    end

    def targets
      targets = Array(packagefile['target'])
      restrict_targets = ENV['THEPACKAGER_TARGET']
      restrict_targets = restrict_targets.split(',').map(&:strip) if restrict_targets
      targets = targets & restrict_targets if restrict_targets
      targets
    end

    def prepare
      Array(packagefile['prepare'])
    end

    def build_dep
      Array(packagefile['build_dep']).to_set
    end

    def before_build
      Array(packagefile['before_build'])
    end

    def docker_server
      packagefile['docker_server']
    end

    def docker_image
      packagefile['image']
    end

    def docker_username
      ENV['THEPACKAGER_DOCKER_USERNAME'] || begin
        raise Error, error: :input_error, message: "THEPACKAGER_DOCKER_USERNAME env variable required"
      end
    end

    def docker_password
      ENV['THEPACKAGER_DOCKER_PASSWORD'] || begin
        raise Error, error: :input_error, message: "THEPACKAGER_DOCKER_PASSWORD env variable required"
      end
    end

    def docker_email
      ENV['THEPACKAGER_DOCKER_EMAIL'] || begin
        raise Error, error: :input_error, message: "THEPACKAGER_DOCKER_EMAIL env variable required"
      end
    end

    def builder
      @builder ||= begin
        build_type = packagefile['build_type']
        klass = {'fpm' => Builder::Fpm}[build_type]
        raise Error, error: :input_error, message: "unknown build_type '#{build_type}'" unless klass
        klass.new(self)
      end
    end

    def thepackager_install_instructions(latest: nil)
      if latest
        ['git clone https://github.com/flant/thepackager ~/thepackager',
         'echo "export BUNDLE_GEMFILE=~/thepackager/Gemfile" | tee -a ~/.bashrc',
         'export BUNDLE_GEMFILE=~/thepackager/Gemfile',
         'gem install bundler',
         'bundle install',
        ]
      else
        'gem install thepackager'
      end
    end
  end # Packager

  class Cli < Thor
    desc "init", "Initialize settings (.travis.yml, .thepackager.yml, git pre-commit hook)"
    method_option :latest,
      type: :boolean,
      desc: "use thepackager github master branch"
    def init
      Packager.new(options: options).init!
    end

    desc "update", "Regenerate .travis.yml"
    def update
      Packager.new(options: options).update!
    end

    desc "deinit", "Deinitialize settings (.thepackager.yml, git pre-commit hook)"
    def deinit
      Packager.new(options: options).deinit!
    end

    desc "prepare", "Prepare images for building packages"
    def prepare
      Packager.new(options: options).prepare!
    end

    desc "build", "Build packages"
    def build
      Packager.new(options: options).build!
    end

    desc "deploy", "Deploy packages"
    def deploy
      Packager.new(options: options).deploy!
    end
  end # Cli
end # Thepackager

begin
  Thepackager::Cli.start
rescue Thepackager::Error => e
  $stderr.puts [e.net_status[:error], e.net_status[:message]].compact.join(': ')
  exit 1
end
