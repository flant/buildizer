#!/usr/bin/env ruby
# vi: set ft=ruby :
# vi: set sts=2 ts=2 sw=2 :

require 'thor'
require 'yaml'
require 'net_status'
require 'pathname'
require 'mixlib/shellout'
require 'net_status'
require 'pry'

module Thepackager
  module Refine
    refine String do
      def underscore
        self.gsub(/(.)([A-Z])/,'\1_\2').downcase
      end
    end
  end # Refine

  using Refine

  module Concern
    def self.included(base)
      base.send(:extend, ClassMethods)
    end

    def command(*command_args, do_raise: nil)
      Mixlib::ShellOut.new(*command_args).tap do |cmd|
        cmd.live_stdout = $stdout
        cmd.run_command
        if cmd.status.success?
          puts [cmd.stdout, cmd.stderr].join("\n")
        elsif do_raise
          raise Error.new(error: :error, message: [cmd.stdout, cmd.stderr].join("\n"))
        end
      end
    end

    def command!(*command_args)
      command(*command_args, do_raise: true)
    end

    module ClassMethods
      def cannonical_name
        self.name.split('::').last.underscore
      end
    end # ClassMethods
  end # Concern

  class Error < NetStatus::Exception
  end # Error

  module Builder
    module Dockerfile
      class Base
        include Concern

        attr_reader :instructions

        def initialize
          @instructions = []

          instruction :FROM, self.class.image
          instruction :MAINTAINER, 'flant <256@flant.com>'
          instruction :ENTRYPOINT, '["/bin/bash", "--login", "-c"]'
          instruction :CMD, '["/bin/bash"]'
        end

        def instruction(instruction, cmd)
          instructions << [instruction.to_s.upcase, cmd].join(' ')
        end

        def build_deps(build_deps)
          raise
        end

        class << self
          def image
            raise
          end

          def os
            cannonical_name
          end
        end # << self
      end # Base

      class Ubuntu < Base
        def initialize
          super

          init = %q{\
sed -i s/mesg/#mesg/ /root/.profile; \
sed -i -r 's/# *(\".*history-search)/\1/' /etc/inputrc; \
echo export DEBIAN_FRONTEND=noninteractive >> /etc/bash.bashrc; \
apt-get update -q}
          instruction :RUN, "bash -lec \"#{init}\""
        end

        def build_deps(build_deps)
          instruction :RUN, "apt-get install -y #{build_deps.to_a.join(' ')}"
        end

        class << self
          def image
            'ubuntu:14.04'
          end
        end # << self
      end # Ubuntu

      class Centos < Base
      end # Centos
    end # Dockerfile

    class Docker
      include Concern

      attr_reader :builder

      def initialize(builder)
        @builder = builder
      end

      def new_dockerfile(os)
        klass = Dockerfile.const_get(os.to_s.split('_').map(&:capitalize).join) rescue nil
        raise Error, message: "unknown os '#{os}'" unless klass
        klass.new
      end

      def build_image(dockerfile)
        os_build_path = builder.build_path.join(dockerfile.class.os)
        os_build_path.mkdir rescue nil
        os_build_path.join('Dockerfile').write [*dockerfile.instructions, nil].join("\n")
        command! "docker build -t thepackager/#{dockerfile.class.os}/#{builder.class.build_type} #{os_build_path}"
      end
    end # Docker

    class Base
      include Concern

      attr_reader :packager
      attr_reader :build_path
      attr_reader :docker

      def initialize(packager)
        @packager = packager

        @build_path = Pathname.new(ENV['PREFIX'] || 'build')
        raise Error, message: "bad build prefix: '#{build_path}' is a file" if build_path.file?
        build_path.mkdir rescue nil

        @docker = Docker.new(self)
      end

      def before_prepare
      end

      def after_prepare
      end

      def build_deps
      end

      def prepare
        common_image_params = {}
        common_image_params[:before_prepare] = Array(packager.packagefile['before_prepare'])
        common_image_params[:after_prepare] = Array(packager.packagefile['after_prepare'])
        common_image_params[:build_deps] = Array(packager.packagefile['build_deps']).to_set
        images = packager.packagefile['os'].to_h.map do |os, params|
          os_params = common_image_params.dup
          os_params[:build_deps] |= Array(params['build_deps']).to_set
          os_params[:before_prepare] += Array(params['before_prepare'])
          os_params[:after_prepare] += Array(params['after_prepare'])
          [os, os_params]
        end.to_h
        images.each {|os, params| prepare_image(os, params)}
      end

      def prepare_image(os, before_prepare: [], after_prepare: [], build_deps: [])
        dockerfile = docker.new_dockerfile(os)

        (Array(self.before_prepare) + before_prepare).each do |cmd|
          dockerfile.instruction(:RUN, "bash -lec \"#{cmd}\"")
        end

        dockerfile.build_deps(Array(self.build_deps).to_set + build_deps)

        (after_prepare + Array(self.after_prepare)).each {|cmd| dockerfile.instruction(:RUN, cmd)}

        docker.build_image(dockerfile)
      end

      def build
        raise "#{self.class}::build"
      end

      class << self
        def build_type
          cannonical_name
        end
      end # << self
    end # Base

    class Fpm < Base
      def before_prepare
        [%Q{\
apt-get install -y curl; \
curl -sSL https://rvm.io/mpapis.asc | gpg --import -; \
curl -sSL https://get.rvm.io | sudo bash -s stable},
         %Q{\
rvm install 2.2.1 --quiet-curl; \
gem install fpm},
        ]
      end
    end # Fpm
  end # Builder

  class Packager
    attr_reader :packagefile_path

    def initialize
      @packagefile_path = Pathname.new(ENV['PACKAGEFILE'] || 'Packagefile')
    end

    def packagefile
      @packagefile ||= YAML.load(@packagefile_path.read)
    end

    def builder
      build_type = packagefile['build_type']
      begin
        builder = Builder.const_get(build_type.split('_').map(&:capitalize).join)
      rescue
				raise Error, error: :input_error, message: "unknown build type '#{build_type}'"
      end
      builder.new(self)
    end
  end # Packager

  class Cli < Thor
    desc "init", "Initialize packager base settings"
    def init
      raise Error, message: ".travis.yml configuration exists" if File.exists?('.travis.yml')

      travis = {
        'dist' => 'trusty',
        'cache' => 'apt',
        'language' => 'ruby',
        'rvm' => '2.2.1',
        'before_install' => 'gem install thepackager',
        'before-script' => 'thepackager prepare',
        'script' => 'thepackager build',
      }

      File.open('.travis.yml', 'w') {|f| f.write YAML.dump(travis)}
    end

    desc "prepare", "Prepare image or environment for build"
    def prepare
      Packager.new.builder.prepare
    end

    desc "build", "Build the package"
    def build
      Packager.new.builder.build
    end
  end # Cli
end # Thepackager

begin
  Thepackager::Cli.start
rescue Thepackager::Error => e
  $stderr.puts [e.net_status[:error], e.net_status[:message]].compact.join(': ')
  exit 1
end
